---
import BaseLayout from '../layouts/BaseLayout.astro';
import FadeIn from '../components/animations/FadeIn.jsx';
import { getCollection } from 'astro:content';
import tagColors, { getTagColors } from '../config/tagColors';
import ThoughtRenderer from '../components/ThoughtRenderer.astro';
import NowItemRenderer from '../components/NowItemRenderer.astro';
import ImageRenderer from '../components/ImageRenderer.astro';
import IdeaRenderer from '../components/IdeaRenderer.astro';
import NewsletterSubscribe from '../components/NewsletterSubscribe.astro';
import AnimatedTag from '../components/animations/AnimatedTag.jsx';
import { createInterleavedFeed, paginateFeed } from '../utils/contentFeed';
import { calculateDoubleWidth } from '../utils/cardUtils';
// import '../styles/index.css';

// Get current page and page size
const { searchParams } = Astro.url;
const currentPage = parseInt(searchParams.get('page') || '1', 10);
const pageSize = 10; // Number of entries per page

// Get all log entries that aren't drafts and aren't CLAUDE.md
const logEntries = await getCollection('log', ({ data, slug }) => {
  return data.draft !== true && slug !== 'claude' && data.title;
});

// Sort entries: featured first, then by date (newest first)
logEntries.sort((a, b) => {
  // Featured articles always come first
  if (a.data.featured && !b.data.featured) return -1;
  if (!a.data.featured && b.data.featured) return 1;
  
  // If both featured or both not featured, sort by date
  const aDate = a.data.updated || a.data.date;
  const bDate = b.data.updated || b.data.date;
  return new Date(bDate).valueOf() - new Date(aDate).valueOf();
});

// Get all thoughts that aren't drafts
const thoughts = await getCollection('thoughts', ({ data }) => {
  return data.draft !== true;
});

// Sort thoughts by date (newest first)
thoughts.sort((a, b) => new Date(b.data.date).valueOf() - new Date(a.data.date).valueOf());

// Get all now entries that aren't drafts
const nowEntries = await getCollection('now', ({ data }) => {
  return data.draft !== true;
});

// Sort now entries by date (newest first)
nowEntries.sort((a, b) => new Date(b.data.date).valueOf() - new Date(a.data.date).valueOf());

// Get all image entries that aren't drafts
const imageEntries = await getCollection('images', ({ data }) => {
  return data.draft !== true;
});

// Sort image entries by date (newest first)
imageEntries.sort((a, b) => new Date(b.data.date).valueOf() - new Date(a.data.date).valueOf());

// Get all idea entries that aren't drafts
const ideaEntries = await getCollection('idea', ({ data }) => {
  return data.draft !== true;
});

// Sort idea entries by date (newest first)
ideaEntries.sort((a, b) => new Date(b.data.date).valueOf() - new Date(a.data.date).valueOf());

// Create interleaved feed with all types using utility function
const allFeedEntries = createInterleavedFeed(
  logEntries,
  thoughts,
  nowEntries,
  imageEntries,
  ideaEntries
);

// Paginate the feed entries using utility function
const { paginatedEntries: feedEntries, totalPages } = paginateFeed(
  allFeedEntries,
  currentPage,
  pageSize
);
---

<BaseLayout title="nibzard - Home" description="all things AI agents, growth and startups" fullWidth={true}>
  <div class="masonry-grid">
    {feedEntries.map((item, index) => {
      return (
        <>
          {item.type === 'thought' ? (
            <FadeIn client:visible delay={index * 0.01} yOffset={5}>
              <ThoughtRenderer entry={item.entry} />
            </FadeIn>
          ) : item.type === 'now' ? (
            <FadeIn client:visible delay={index * 0.01} yOffset={5}>
              <NowItemRenderer entry={item.entry} />
            </FadeIn>
          ) : item.type === 'image' ? (
            <FadeIn client:visible delay={index * 0.01} yOffset={5}>
              <div class="image-container">
                <ImageRenderer entry={item.entry} />
              </div>
            </FadeIn>
          ) : item.type === 'idea' ? (
            <FadeIn client:visible delay={index * 0.01} yOffset={5}>
              <IdeaRenderer entry={item.entry} />
            </FadeIn>
          ) : (
            <FadeIn client:visible delay={index * 0.01} yOffset={5}>
              {(() => {
                const logEntry = item.entry;
                const { isDoubleWidth, borderStyle } = calculateDoubleWidth(logEntry.slug, feedEntries);

                return (
                  <article
                    class={`log-entry ${isDoubleWidth ? 'double-width' : ''}`}
                    style={borderStyle}
                    data-href={`/${logEntry.slug}`}
                    role="button"
                    tabIndex="0"
                    aria-label={`Read article: ${'title' in logEntry.data ? logEntry.data.title : 'Log Entry'}`}
                  >
                    <div class="entry-meta">
                      <time datetime={(logEntry.data.updated || logEntry.data.date).toISOString()}>
                        {logEntry.data.updated ? (
                          <>
                            <span class="updated-indicator">Updated</span>{' '}
                            {new Date(logEntry.data.updated).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })}
                          </>
                        ) : (
                          new Date(logEntry.data.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })
                        )}
                      </time>
                    </div>
                    <div class="log-entry-content">
                      <h2>{'title' in logEntry.data ? logEntry.data.title : 'Log Entry'}</h2>
                      {'tldr' in logEntry.data && logEntry.data.tldr && (
                        <p class="log-entry-tldr">{logEntry.data.tldr}</p>
                      )}
                    </div>
                    <div class="entry-tags">
                      {'tags' in logEntry.data && logEntry.data.tags && logEntry.data.tags.length > 0 && (
                        <div class="tag-container">
                          {logEntry.data.tags.map((tag: string) => {
                              const formattedTag = tag;
                              return (
                                <AnimatedTag
                                  client:visible
                                  href={`/tags/${tag.toLowerCase()}`}
                                  tagText={formattedTag}
                                />
                              );
                            })}
                          </div>
                        )}
                      </div>
                  </article>
                );
              })()}
            </FadeIn>
          )}
        </>
      );
    })}
  </div>

  {totalPages > 1 && (
    <nav class="pagination" aria-label="Pagination" style="margin-top: var(--space-lg); margin-bottom: var(--space-lg);">
      {currentPage > 1 && (
        <a href={`/?page=${currentPage - 1}`} class="pagination-prev" aria-label="Previous page">←</a>
      )}
      {Array.from({ length: totalPages }, (_, i) => i + 1).map(page => (
        <a
          href={`/?page=${page}`}
          class={`pagination-page ${page === currentPage ? 'pagination-active' : ''}`}
          aria-current={page === currentPage ? 'page' : undefined}
        >
          {page}
        </a>
      ))}
      {currentPage < totalPages && (
        <a href={`/?page=${currentPage + 1}`} class="pagination-next" aria-label="Next page">→</a>
      )}
    </nav>
  )}
  {/* Insert newsletter at the bottom */}
  <FadeIn client:visible delay={0} yOffset={5}>
    <div class="newsletter-section">
      <NewsletterSubscribe
        title="Stay Updated"
        description="Subscribe to receive the latest updates and articles directly in your inbox."
        showButton={true}
      />
    </div>
  </FadeIn>
</BaseLayout>

<script>
  // @ts-nocheck
  // Render feed entries dynamically (client-side)
  window.renderFeed = function(entries, container) {
    // This function should clear and re-render the feedTimeline div
    // For brevity, we'll just reload the page if search is cleared, or show a message if no results
    if (!entries.length) {
      container.innerHTML = '<div style="text-align:center;color:var(--color-text-muted);padding:2rem;">No results found.</div>';
      return;
    }
    // Optionally, you can render a simplified version or re-use server-rendered HTML snippets
    // For now, reload page if search is cleared (fallback)
    location.reload();
  };
  // @ts-nocheck
  // Initialize functionality for the interactive elements
  document.addEventListener('DOMContentLoaded', () => {
    // Handle card clicks and keyboard navigation for log entries
    const logEntries = document.querySelectorAll('.log-entry');
    const nowItems = document.querySelectorAll('.now-item');

    // Function to handle clickable cards
    const makeCardClickable = (card) => {
      // Handle card clicks
      card.addEventListener('click', (e) => {
        // Check if click is on a tag link (only for log entries)
        const isTagClick = e.target.closest('.entry-tags .tag');
        if (!isTagClick) {
          // Navigate to destination
          const href = card.getAttribute('data-href');
          if (href) {
            window.location.href = href;
          }
        }
      });

      // Handle keyboard navigation
      card.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const href = card.getAttribute('data-href');
          if (href) {
            window.location.href = href;
          }
        }
      });
    };

    // Make log entries clickable
    logEntries.forEach(makeCardClickable);

    // Make now items clickable
    nowItems.forEach(makeCardClickable);

    // Newsletter form handling
    const newsletterForm = document.querySelector('.newsletter-form');
    if (newsletterForm) {
      newsletterForm.addEventListener('submit', (e) => {
        e.preventDefault();
        // In a real implementation, this would send the form data to a server
        const emailInput = newsletterForm.querySelector('input[type="email"]');
        if (emailInput && emailInput.value) {
          // Show success message (replace alert with better UX)
          const successMsg = document.createElement('div');
          successMsg.textContent = 'Thank you for subscribing!';
          successMsg.style.cssText = 'color: var(--color-accent1); font-size: 0.9rem; margin-top: 0.5rem;';
          emailInput.parentNode.appendChild(successMsg);
          setTimeout(() => successMsg.remove(), 3000);
          emailInput.value = '';
        }
      });
    }
  });
</script>
